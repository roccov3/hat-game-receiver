<!DOCTYPE html>
<html>
<head>
  <title>Hat Game Receiver</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      width: 100%;
      height: 100%;
      background-color: #000;
      overflow: hidden;
    }
    #media-container {
      position: relative;
      width: 100%;
      height: 100%;
    }
    video {
      width: 100%;
      height: 100%;
    }
    #overlay-image {
      position: absolute;
      top: 50%;
      left: 50%;
      width: 15vw;
      display: none;
      transform: translate(-50%, -50%) rotate(0deg) scale(1);
    }
  </style>
</head>
<body>
  <script type="text/javascript" src="https://www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
  <script type="text/javascript" src="https://www.gstatic.com/cast/sdk/libs/mediaplayer/v1/media_player.js"></script>

  <div id="media-container">
    <cast-media-player
      supported-commands="pause,play,stream_volume,stream_mute"
    ></cast-media-player>
    <img id="overlay-image" />
  </div>

  <script>
    const context = cast.framework.CastReceiverContext.getInstance();
    const playerManager = context.getPlayerManager();
    const overlayImage = document.getElementById('overlay-image');
    const CUSTOM_NAMESPACE = 'urn:x-cast:com.example.hatgameapp.custom';

    const castReceiverOptions = new cast.framework.CastReceiverOptions();
    castReceiverOptions.disableIdleTimeout = true;
    castReceiverOptions.supportedCommands = cast.framework.messages.Command.ALL_BASIC_MEDIA;

    context.addEventListener(cast.framework.events.EventType.READY, () => {
      console.log('Cast Receiver is READY.');

      playerManager.setMediaInformationHandler((loadRequest) => {
        console.log('Intercepting LOAD request.');
        if (loadRequest.media && loadRequest.media.customData) {
          const customData = loadRequest.media.customData;
          if (customData.overlayUrl) {
            overlayImage.src = customData.overlayUrl;
            overlayImage.style.display = 'block';
          } else {
            overlayImage.style.display = 'none';
          }
        }
        return loadRequest;
      });

      context.addCustomMessageListener(CUSTOM_NAMESPACE, (customEvent) => {
        const data = customEvent.data;
        if (data.type === 'UPDATE_OVERLAY') {
          console.log('Received UPDATE_OVERLAY message:', data);
          const x = data.x;
          const y = data.y;
          const scale = data.scale;
          const rotation = data.rotation;

          overlayImage.style.left = `${x * 100}vw`;
          overlayImage.style.top = `${y * 100}vh`;
          overlayImage.style.transform = `translate(-50%, -50%) rotate(${rotation}deg) scale(${scale})`;
        }
      });
    });

    // Enable verbose logging for debugging
    cast.framework.setLoggerLevel(cast.framework.LoggerLevel.DEBUG);

    context.start(castReceiverOptions);
  </script>
</body>
</html>
